---
title: 闭包
category: JS基础
date: 2020-09-02 10:40
top: 97
---

## 一、闭包的定义

> 官方定义：

> 闭包就是能够读取其他函数内部变量的函数。
> 例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。
> 在本质上，闭包是将函数内部和函数外部连接起来的桥梁。

> 闭包是JS语言的一种特性，闭包通常是一个`函数`
> 函数是一个独立的作用域，独利的作用域外部环境无法访问，就是`闭`
> 封闭自己的词法作用域，函数有许多特殊形式的函数，这就成就了`包`

## 二、为什么要使用闭包

> **先介绍一下全局变量和局部变量的优缺点**
> **全局变量：** 可以重用、但是会造成全局污染而且容易被篡改。
> **局部变量：** 仅函数内使用不会造成全局污染也不会被篡改、不可以重用。
> 所以，全局变量和局部变量的优缺点刚好相对。闭包的出现正好结合了全局变量和局部变量的优点。

总之，希望重用一个对象，但是又保护对象不被污染篡改时，就需要使用闭包了。

## 三、闭包的表现形式

一般有两种情况
- 函数作为返回值
- 函数作为参数传递

**1. 函数作为返回值**

```js
function fn() {
  var max = 10
  return function bar (x) {
    if (x > max) {
      console.log(x)
    }
  }
}
var f1 = fn()
f1(15)
```

**2. 函数作为参数传值**
```js
var max = 10
function bar (x) {
  if (x > max) {
    console.log(x)
  }
}
(function (f){
  var max = 100
  f(15)
})(bar)
```
自由变量跨作用域取值时，曾经强调过：要去创建这个函数的作用域取值，而不是“父作用域”。理解了这一点，以上两端代码中，自由变量如何取值应该比较简单。

## 四、闭包和执行上下文

**1. 代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。**
![](../../assets/JS基础/context1.png)

**2. 执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态，执行fn，给max赋值**
![](../../assets/JS基础/context2.png)

**3. 执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn()时，`返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域`。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁**

因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。

**4. 执行到第18行，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中**

![](../../assets/JS基础/context3.png)

**5. 执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态**

![](../../assets/JS基础/context4.png)


这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。

`使用闭包会增加内容开销`，现在很明显了吧！

## 五、闭包形成的原因


## 六、闭包的应用
